{# Django Base Template - RavaDev #}
{% load static %}
<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RavaDev ‚Ä¢ {% block appTitle %}Aplikacja{% endblock %} ‚Ä¢ {% block moduleTitle %}Modu≈Ç{% endblock %}</title>
    
    <!-- Stylesheets -->
    <link rel="stylesheet" href="{% static 'css/style.css' %}">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        /* Mobile Menu Styles - NAPRAWIONE */
        .hamburger-menu {
            display: none;
            flex-direction: column;
            cursor: pointer;
            padding: 10px;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 8px;
        }

        .hamburger-menu span {
            display: block;
            width: 25px;
            height: 3px;
            background: #fff;
            margin: 2px 0;
            transition: 0.3s;
        }

        .nav-links {
            display: flex;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .hamburger-menu {
                display: flex;
            }

            .nav-links {
                display: none;
                position: fixed;
                top: 0;
                right: 0;
                flex-direction: column;
                background: rgba(0, 0, 0, 0.95);
                backdrop-filter: blur(20px);
                padding: 80px 20px 20px;
                width: 250px;
                height: 100vh;
                z-index: 999;
            }

            .nav-links.active {
                display: flex;
            }

            .hamburger-menu.active span:nth-child(1) {
                transform: rotate(45deg) translate(5px, 5px);
            }

            .hamburger-menu.active span:nth-child(2) {
                opacity: 0;
            }

            .hamburger-menu.active span:nth-child(3) {
                transform: rotate(-45deg) translate(5px, -5px);
            }
        }

        /* Snap Scroll Styles - NOWE */
        .snap-container {
            height: 100vh;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            scroll-behavior: smooth;
        }

        .snap-section {
            scroll-snap-align: start;
            min-height: 100vh;
            padding: clamp(3rem, 10vw, 6rem) 0;
            display: flex;
            align-items: center;
            position: relative;
        }

        /* Ensure proper spacing with fixed navbar */
        .snap-section:first-child {
            padding-top: clamp(120px, 15vw, 140px);
        }
    </style>
</head>
<body>
    <!-- Particles Container -->
    <div id="particles-js"></div>

    <!-- Header & Navigation -->
    <header class="navbar">
        <div class="container">
            <span class="wordmark">
                {% include '_includes/wordmark.html' %}
            </span>
            
            <div class="hamburger-menu" id="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>

            <nav class="nav-links" id="navLinks">
                <a href="{% url 'Main:index' %}">Strona g≈Ç√≥wna</a>
                <a href="{% url 'Blog:blog' %}">Blog</a>
                <a href="{% url 'Services:services' %}">Us≈Çugi</a>
                <a href="{% url 'Projects:projects' %}">Realizacje</a>
                <a href="{% url 'Contact:contact' %}">Kontakt</a>
            </nav>
        </div>
    </header>










<canvas id="bgCanvas" aria-hidden="true" class="background-animation"></canvas>
      <div class="overlay">
        <div class="title hidden">
          <h1>G√≥ry z lotu ptaka</h1>
          <p class="lead">Interaktywna, proceduralna scena terenu generowana w shaderze; reaguje na ruch kursora i dotyk.</p>
        </div>
        <div class="panel controls hidden" aria-hidden="false">
          <label class="control hidden">
            Scale
            <input id="uScale" type="range" min="0.6" max="3.2" step="0.01" value="1.25" style="width:120px;margin-left:8px;vertical-align:middle;">
          </label>
          <label class="control hidden">
            Elevation
            <input id="uElev" type="range" min="0.15" max="2.4" step="0.01" value="0.85" style="width:120px;margin-left:8px;">
          </label>
          <label class="control hidden">
            Speed
            <input id="uSpeed" type="range" min="0.0" max="1.2" step="0.01" value="0.42" style="width:120px;margin-left:8px;">
          </label>
          <div class="legend hidden">Przesu≈Ñ kursor, aby przechylaƒá widok.</div>
        </div>
      </div>
    </canvas>














    <!-- Flash Messages -->
    {% if messages %}
    <div class="messages-container">
        {% for message in messages %}
        <div class="alert alert-{{ message.tags }} fade-in">
            <div class="alert-content">
                <span class="alert-icon">
                    {% if message.tags == 'success' %}‚úÖ
                    {% elif message.tags == 'error' %}‚ùå
                    {% elif message.tags == 'warning' %}‚ö†Ô∏è
                    {% elif message.tags == 'info' %}‚ÑπÔ∏è
                    {% else %}üîî{% endif %}
                </span>
                <span class="alert-text">{{ message }}</span>
            </div>
            <button class="alert-close" onclick="this.parentElement.remove()">
                <span>√ó</span>
            </button>
        </div>
        {% endfor %}
    </div>
    {% endif %}

    <!-- Main Content -->
    <main>
    <div class="snap-container">

        <!-- Domy≈õlny kontener bez snap scroll -->
        <div class="container">
            <div class="main-content glass">
                <header class="content-header text-center">
                    <h1 class="text-gradient">{% block appHeader %}{% endblock %}</h1>
                    <p class="lead">{% block moduleHeader %}{% endblock %}</p>
                </header>
                
                <div class="content-body">
                    {% block content %}
                    <!-- Content goes here -->
                    {% endblock %}
                </div>
            </div>
        </div>
    </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3 class="logo">RavaDev</h3>
                    <p>Tworzymy nowoczesne rozwiƒÖzania cyfrowe dla Twojego biznesu.</p>
                </div>
                
                <div class="footer-section">
                    <h4>Szybkie linki</h4>
                    <ul>
                        <li><a href="{% url 'Main:index' %}">Strona g≈Ç√≥wna</a></li>
                        <li><a href="{% url 'Services:services' %}">Us≈Çugi</a></li>
                        <li><a href="{% url 'Projects:projects' %}">Realizacje</a></li>
                        <li><a href="{% url 'Contact:contact' %}">Kontakt</a></li>
                    </ul>
                </div>
                
                <div class="footer-section">
                    <h4>Us≈Çugi</h4>
                    <ul>
                        <li><a href="#">Web Development</a></li>
                        <li><a href="#">Aplikacje Mobilne</a></li>
                        <li><a href="#">UI/UX Design</a></li>
                        <li><a href="#">Consulting</a></li>
                    </ul>
                </div>
                
                <div class="footer-section">
                    <h4>Kontakt</h4>
                    <p>email: kontakt@ravadev.pl</p>
                    <p>tel: +48 123 456 789</p>
                </div>
            </div>
            
            <div class="footer-bottom">
                <p>&copy; 2024 RavaDev. Wszelkie prawa zastrze≈ºone.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script>
        // Mobile Menu Toggle
        const hamburger = document.getElementById('hamburger');
        const navLinks = document.getElementById('navLinks');
        
        if (hamburger && navLinks) {
            hamburger.addEventListener('click', function() {
                hamburger.classList.toggle('active');
                navLinks.classList.toggle('active');
            });

            // Close mobile menu when clicking on a link
            document.querySelectorAll('.nav-links a').forEach(link => {
                link.addEventListener('click', () => {
                    hamburger.classList.remove('active');
                    navLinks.classList.remove('active');
                });
            });
        }

        // Navbar Scroll Effect
        window.addEventListener('scroll', function() {
            const navbar = document.querySelector('.navbar');
            if (navbar && window.scrollY > 100) {
                navbar.classList.add('scrolled');
            } else if (navbar) {
                navbar.classList.remove('scrolled');
            }
        });

        // Auto-dismiss Messages
        document.addEventListener('DOMContentLoaded', function() {
            const alerts = document.querySelectorAll('.alert');
            alerts.forEach(alert => {
                setTimeout(() => {
                    alert.style.opacity = '0';
                    alert.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (alert.parentElement) {
                            alert.remove();
                        }
                    }, 300);
                }, 5000);
            });
        });

        // Smooth Scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Enhanced Snap Scroll functionality
        function initSnapScroll() {
            const snapContainer = document.querySelector('.snap-container');
            if (snapContainer) {
                let isScrolling = false;
                
                snapContainer.addEventListener('scroll', () => {
                    if (!isScrolling) {
                        isScrolling = true;
                        
                        // Add active class to current section
                        const sections = document.querySelectorAll('.snap-section');
                        const containerScroll = snapContainer.scrollTop;
                        const containerHeight = snapContainer.clientHeight;
                        
                        sections.forEach((section, index) => {
                            const sectionTop = section.offsetTop;
                            const sectionHeight = section.clientHeight;
                            
                            if (containerScroll >= sectionTop - containerHeight * 0.3 && 
                                containerScroll < sectionTop + sectionHeight - containerHeight * 0.3) {
                                section.classList.add('active');
                                // Update URL hash
                                const sectionId = section.id || `section-${index + 1}`;
                                history.replaceState(null, null, `#${sectionId}`);
                            } else {
                                section.classList.remove('active');
                            }
                        });
                        
                        setTimeout(() => {
                            isScrolling = false;
                        }, 100);
                    }
                });

                // Keyboard navigation for snap scroll
                snapContainer.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                        e.preventDefault();
                        const currentScroll = snapContainer.scrollTop;
                        const sectionHeight = snapContainer.clientHeight;
                        const newScroll = e.key === 'ArrowDown' 
                            ? currentScroll + sectionHeight 
                            : currentScroll - sectionHeight;
                        
                        snapContainer.scrollTo({
                            top: newScroll,
                            behavior: 'smooth'
                        });
                    }
                });
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initSnapScroll();
            
            // Particles.js initialization
            if (typeof particlesJS !== 'undefined') {
                particlesJS('particles-js', {
                    particles: {
                        number: { value: 80, density: { enable: true, value_area: 800 } },
                        color: { value: "#00ffd5" },
                        shape: { type: "circle" },
                        opacity: { value: 0.5, random: true },
                        size: { value: 3, random: true },
                        line_linked: {
                            enable: true,
                            distance: 150,
                            color: "#00ffd5",
                            opacity: 0.2,
                            width: 1
                        },
                        move: {
                            enable: true,
                            speed: 2,
                            direction: "none",
                            random: true,
                            out_mode: "out"
                        }
                    },
                    interactivity: {
                        detect_on: "canvas",
                        events: {
                            onhover: { enable: true, mode: "repulse" },
                            onclick: { enable: true, mode: "push" }
                        }
                    }
                });
            }
        });

        // Touch device improvements for snap scroll
        let touchStartY = 0;
        document.addEventListener('touchstart', e => {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        document.addEventListener('touchend', e => {
            const touchEndY = e.changedTouches[0].clientY;
            const diff = touchStartY - touchEndY;
            const snapContainer = document.querySelector('.snap-container');
            
            if (snapContainer && Math.abs(diff) > 50) {
                // Let native snap scroll handle it
            }
        }, { passive: true });
    </script>
    <script>

/* Konfigurowalne kolory na poczƒÖtku skryptu */
const COLORS = {
  bg: '#222222',            // t≈Ço
  primary: '#30d5c8',       // turkus (primary)
  secondary: '#ff00ff'      // magenta (secondary)
};

/* ====== Ustawienia renderer, scena, kamera ====== */
const canvas = document.getElementById('bgCanvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
renderer.autoClear = true;
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.background = new THREE.Color(COLORS.bg);

/* Kamera z lotu ptaka */
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 48, 78);
camera.lookAt(0, 0, 0);

/* ≈öwiat≈Ça - barwy dobrane wzglƒôdem palety */
const ambient = new THREE.AmbientLight(0xffffff, 0.55);
scene.add(ambient);
const sunColor = new THREE.Color().setStyle(COLORS.primary).lerp(new THREE.Color(0xffffff), 0.25);
const sun = new THREE.DirectionalLight(sunColor, 0.9);
sun.position.set(50, 80, 40);
scene.add(sun);

/* UI kontrolki (je≈õli istniejƒÖ na stronie) */
const ui = {
  scale: (typeof document !== 'undefined' && document.getElementById('uScale')) ? parseFloat(document.getElementById('uScale').value) : 1.25,
  elev:  (typeof document !== 'undefined' && document.getElementById('uElev')) ? parseFloat(document.getElementById('uElev').value) : 0.85,
  speed: (typeof document !== 'undefined' && document.getElementById('uSpeed')) ? parseFloat(document.getElementById('uSpeed').value) : 0.42
};
if (document.getElementById('uScale')) document.getElementById('uScale').addEventListener('input', e => ui.scale = parseFloat(e.target.value));
if (document.getElementById('uElev'))  document.getElementById('uElev').addEventListener('input', e => ui.elev = parseFloat(e.target.value));
if (document.getElementById('uSpeed')) document.getElementById('uSpeed').addEventListener('input', e => ui.speed = parseFloat(e.target.value));

/* ====== Geometria terenu ====== */
const segmentsX = 256;
const segmentsY = 256;
const planeSize = 220;
const geometry = new THREE.PlaneGeometry(planeSize, planeSize, segmentsX, segmentsY);
geometry.rotateX(-Math.PI / 2);

/* Pomoc: konwersja HEX -> vec3 (0..1) dla shader√≥w */
function hexToVec3(hex){
  const c = new THREE.Color(hex);
  return [c.r, c.g, c.b];
}
const primaryVec = hexToVec3(COLORS.primary);
const secondaryVec = hexToVec3(COLORS.secondary);

/* ====== Shader material ====== */
const material = new THREE.ShaderMaterial({
  uniforms: {
    uTime: { value: 0.0 },
    uScale: { value: ui.scale },
    uElevation: { value: ui.elev },
    uSpeed: { value: ui.speed },
    uLightDir: { value: new THREE.Vector3(0.6, 0.8, 0.4) },
    uCameraPos: { value: camera.position },
    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
    uPrimary: { value: new THREE.Vector3(primaryVec[0], primaryVec[1], primaryVec[2]) },
    uSecondary: { value: new THREE.Vector3(secondaryVec[0], secondaryVec[1], secondaryVec[2]) }
  },
  vertexShader: `
    varying vec3 vPos;
    varying vec3 vNormal;
    varying vec2 vUv;
    uniform float uTime;
    uniform float uScale;
    uniform float uElevation;
    uniform float uSpeed;

    // Simplex noise (2D) - Ashima / Ian McEwan
    vec3 mod289(vec3 x){ return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec2 mod289(vec2 x){ return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec3 permute(vec3 x){ return mod289(((x*34.0)+1.0)*x); }
    float snoise(vec2 v){
      const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                          -0.577350269189626, 0.024390243902439);
      vec2 i = floor(v + dot(v, C.yy) );
      vec2 x0 = v - i + dot(i, C.xx);
      vec2 i1;
      i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
      vec4 x12 = x0.xyxy + C.xxzz;
      x12.xy -= i1;
      i = mod289(i);
      vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                      + i.x + vec3(0.0, i1.x, 1.0 ));
      vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
      m = m*m; m = m*m;
      vec3 x = 2.0 * fract(p * C.www) - 1.0;
      vec3 h = abs(x) - 0.5;
      vec3 ox = floor(x + 0.5);
      vec3 a0 = x - ox;
      m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
      vec3 g;
      g.x  = a0.x * x0.x + h.x * x0.y;
      g.yz = a0.yz * x12.xz + h.yz * x12.yw;
      return 130.0 * dot(m, g);
    }

    void main(){
      vUv = uv;
      vec3 pos = position;
      float t = uTime * 0.2 * uSpeed;
      float n = 0.0;
      float amp = 1.0;
      float freq = 1.0;
      for(int i=0;i<4;i++){
        n += snoise((pos.xz * 0.02 * freq) + vec2(t, -t)) * amp;
        freq *= 2.0;
        amp *= 0.5;
      }
      n = abs(n);
      float elevation = pow(n, 1.6) * uElevation * 8.0;
      pos.y += elevation;
      vPos = pos;
      vNormal = normalMatrix * normal;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  `,
  fragmentShader: `
    varying vec3 vPos;
    varying vec3 vNormal;
    varying vec2 vUv;
    uniform vec3 uLightDir;
    uniform vec3 uCameraPos;
    uniform vec3 uPrimary;
    uniform vec3 uSecondary;

    // Paleta bazowana na primary/secondary
    vec3 palette(float h){
      // base colors blended from primary -> secondary with altitude tints
      vec3 baseLow = mix(uPrimary * 0.25, uSecondary * 0.05, 0.15);
      vec3 baseMid = mix(uPrimary * 0.6, uSecondary * 0.25, 0.35);
      vec3 baseHigh = mix(uPrimary * 0.95, vec3(0.95,0.95,0.98), 0.25);
      vec3 peak = mix(uSecondary, vec3(0.98,0.98,1.0), 0.4);

      if(h < 0.25) return mix(baseLow, baseMid, smoothstep(0.0,0.25,h/0.25));
      if(h < 0.6) return mix(baseMid, baseHigh, smoothstep(0.25,0.6,(h-0.25)/0.35));
      return mix(baseHigh, peak, smoothstep(0.6,1.0,(h-0.6)/0.4));
    }

    void main(){
      float height = clamp(vPos.y / 20.0, 0.0, 1.0);
      vec3 baseColor = palette(height);

      vec3 N = normalize(vNormal);
      vec3 L = normalize(uLightDir);
      float diff = clamp(dot(N, L), 0.0, 1.0);
      float rim = pow(1.0 - max(dot(normalize(uCameraPos - vPos), N), 0.0), 3.0);
      vec3 color = baseColor * (0.35 + diff * 0.8) + vec3(0.12,0.14,0.15) * rim;

      float fogFactor = smoothstep(120.0, 220.0, length(uCameraPos - vPos));
      vec3 fogColor = vec3(0.02, 0.04, 0.08);
      color = mix(color, fogColor, fogFactor);

      float haze = smoothstep(0.0, 0.25, 1.0 - height) * 0.06;
      color += haze;

      gl_FragColor = vec4(color, 1.0);
    }
  `,
  side: THREE.DoubleSide,
  transparent: false
});

/* ====== Mesh terenu i dodatkowe warstwy ====== */
const terrain = new THREE.Mesh(geometry, material);
terrain.receiveShadow = true;
scene.add(terrain);

/* Dyskretna warstwa chmur/mg≈Çy */
const cloudGeo = new THREE.PlaneGeometry(900, 900, 1, 1);
const cloudMat = new THREE.MeshBasicMaterial({ color: new THREE.Color().setStyle(COLORS.secondary).multiplyScalar(0.12), transparent: true, depthWrite: false });
const cloudPlane = new THREE.Mesh(cloudGeo, cloudMat);
cloudPlane.rotation.x = -Math.PI/2;
cloudPlane.position.y = 28;
scene.add(cloudPlane);

/* Interakcja pointer/touch */
const pointer = { x: 0, y: 0, px: 0, py: 0 };
function onPointer(e){
  const cx = e.clientX || (e.touches && e.touches[0].clientX) || window.innerWidth/2;
  const cy = e.clientY || (e.touches && e.touches[0].clientY) || window.innerHeight/2;
  pointer.x = (cx / window.innerWidth) * 2 - 1;
  pointer.y = (cy / window.innerHeight) * 2 - 1;
}
window.addEventListener('pointermove', onPointer, { passive: true });
window.addEventListener('touchmove', onPointer, { passive: true });

/* Optymalizacje FPS */
const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
const targetFps = isMobile ? 30 : 60;
let lastFrame = performance.now();
let raf;

/* Responsywno≈õƒá */
function resize(){
  const w = window.innerWidth;
  const h = window.innerHeight;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, isMobile ? 1.3 : 2));
  renderer.setSize(w, h, false);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  if(material.uniforms && material.uniforms.uResolution) material.uniforms.uResolution.value.set(w, h);
}
window.addEventListener('resize', resize, { passive: true });
resize();

/* Animacja */
function animate(now){
  raf = requestAnimationFrame(animate);
  const dt = now - lastFrame;
  if (dt < (1000 / targetFps) * 0.7) return;
  lastFrame = now;

  // smoothing pointer
  pointer.px += (pointer.x - pointer.px) * 0.08;
  pointer.py += (pointer.y - pointer.py) * 0.08;

  // kamera porusza siƒô nad terenem zale≈ºnie od kursora
  const camTargetX = pointer.px * 28;
  const camTargetZ = 60 + pointer.py * -18;
  camera.position.x += (camTargetX - camera.position.x) * 0.06;
  camera.position.z += (camTargetZ - camera.position.z) * 0.06;
  camera.position.y += (48 + pointer.py * -18 - camera.position.y) * 0.06;
  camera.lookAt(0, 0, 0);

  // rotacja terenu dla subtelnego parallaxu
  terrain.rotation.y = pointer.px * 0.08;

  // przesuwanie chmur
  cloudPlane.position.x += 0.02 * ui.speed;
  cloudPlane.position.z += 0.01 * ui.speed;

  // aktualizacja uniform√≥w
  material.uniforms.uTime.value = now * 0.001;
  material.uniforms.uScale.value = ui.scale;
  material.uniforms.uElevation.value = ui.elev;
  material.uniforms.uSpeed.value = ui.speed;
  material.uniforms.uLightDir.value.set(0.6, 0.8, 0.4);
  material.uniforms.uCameraPos.value.copy(camera.position);
  material.uniforms.uPrimary.value.set(primaryVec[0], primaryVec[1], primaryVec[2]);
  material.uniforms.uSecondary.value.set(secondaryVec[0], secondaryVec[1], secondaryVec[2]);

  renderer.render(scene, camera);
}
raf = requestAnimationFrame(animate);

/* Oszczƒôdzanie zasob√≥w gdy karta niewidoczna */
document.addEventListener('visibilitychange', () => {
  if (document.hidden) cancelAnimationFrame(raf);
  else { lastFrame = performance.now(); raf = requestAnimationFrame(animate); }
});

/* Czyszczenie przy zamkniƒôciu strony / SPA */
window.addEventListener('unload', () => {
  cancelAnimationFrame(raf);
  geometry.dispose();
  material.dispose();
  cloudGeo.dispose();
  cloudMat.dispose();
  renderer.dispose();
});


    </script>
    {% block extra_js %}{% endblock %}
</body>
</html>